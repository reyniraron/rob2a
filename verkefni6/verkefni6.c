#pragma config(Sensor, in4,    lineFollowerRIGHT, sensorLineFollower)
#pragma config(Sensor, in5,    lineFollowerCENTER, sensorLineFollower)
#pragma config(Sensor, in6,    lineFollowerLEFT, sensorLineFollower)
#pragma config(Sensor, dgtl1,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                             	             - Verkefni 6 -                                           *|
|*                                                                                                    *|
|*  This program tells the robot to follow a path to fetch a glass and bring it back to a basket.     *|
|*  Then it repeats this process until it has fethced all the glasses and returned them.              *|
|*                                                                                                    *|
\*-----------------------------------------------------------------------------------------------4246-*/

#include "headers/stop.h"
#include "functions/stop.inc"
#include "headers/motor.h"
#include "functions/motor.inc"
#include "headers/encoders.h"
#include "functions/encoders.inc"
#include "headers/linefollowers.h"
#include "functions/linefollowers.inc"

#define POWER 45
#define LOW_POWER POWER / 4

const int threshold = 2340;  // Found by adding sensor values for dark and light together and dividing by 2

typedef struct LinePart {
	int startTurn;
	int distance;
	int endTurn;
} LinePart;

// Set LinePart values
void updateLinePart(LinePart &linePart, int startTurn, int distance, int endTurn) {
	linePart.startTurn = startTurn;
	linePart.distance = distance;
	linePart.endTurn = endTurn;
}

// Array of paths
LinePart paths[4][5];

void findLine(int sensorNo, int lastEncoderValue, int threshold, int fullPower, int lowPower) {
	// TODO: Try driving backwards to position where line was last seen and then turning
	writeDebugStreamLine("Finding line using sensor %d...", sensorNo);
	// -1 = left
  // 0 = center
  // 1 = right

	// If left saw the line last, steer left
	if (sensorNo == -1) {
		// writeDebugStreamLine("Turning left");

		if (SensorValue(lineFollowerLEFT) < threshold) {
			motor[leftMotor] = lowPower;
			motor[rightMotor] = fullPower;
			wait1Msec(500);
			stopMotors();
		}
	}
	// If right saw the line last, steer right
	else if (sensorNo == 1) {
		// writeDebugStreamLine("Turning right");

		if (SensorValue(lineFollowerRIGHT) < threshold) {
			motor[leftMotor] = fullPower;
			motor[rightMotor] = lowPower;
			wait1Msec(500);
			stopMotors();
		}
	}
	// If center saw the line last, the function should not have been called!
	else {
		// writeDebugStreamLine("Why did this function get called?");
		motor[leftMotor] = fullPower;
		motor[rightMotor] = fullPower;
	}
}

bool isOnLine = false;
int maxSensorNo = 0;

task watchLine() {
  int encoderValue = SensorValue[rightEncoder];;
  while (true) {
  	// Show sensor values on LCD
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -+
    displayLCDCenteredString(0, "LEFT  CNTR  RGHT");        //            |
    displayLCDPos(1, 0);                                    //            |
    displayNextLCDNumber(SensorValue(lineFollowerLEFT));    //            |
    displayLCDPos(1, 6);                                    //            |
    displayNextLCDNumber(SensorValue(lineFollowerCENTER));  //            |
    displayLCDPos(1, 12);                                   //  L  C  R   |
    displayNextLCDNumber(SensorValue(lineFollowerRIGHT));   //  x  x  x   |
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -+

    int leftValue = SensorValue(lineFollowerLEFT);
    int centerValue = SensorValue(lineFollowerCENTER);
    int rightValue = SensorValue(lineFollowerRIGHT);

    // writeDebugStreamLine("Max sensor: %d", maxSensorNo);

    isOnLine = false;
    // If right sensor sees dark, counter-steer right
    if (rightValue > threshold) {
      // motor[leftMotor]  = POWER;
      // motor[rightMotor] = LOW_POWER;

      // Right has highest value
      if (rightValue > centerValue && rightValue > leftValue) {
      	// writeDebugStreamLine("Right has highest value...");
	    	maxSensorNo = 1;
	    }
	    isOnLine = true;
    }
    // If center sensor sees dark, go straight
    if (centerValue > threshold) {
      // motor[leftMotor]  = POWER;
      // motor[rightMotor] = POWER;

      // Center has highest value
      if (centerValue > leftValue && centerValue > rightValue) {
      	// writeDebugStreamLine("Center has highest value...");
    		maxSensorNo = 0;
    	}
    	isOnLine = true;
    }
    // If left sensor sees dark, counter-steer left
    if (leftValue > threshold) {
      // motor[leftMotor]  = LOW_POWER;
      // motor[rightMotor] = POWER;

      // Left has highest value
	    if (leftValue > centerValue && leftValue > rightValue) {
	    	// writeDebugStreamLine("Left has highest value...");
	    	maxSensorNo = -1;
	    }
	    isOnLine = true;
    }
    // Wait until robot is on line

		if (!isOnLine) {
			writeDebugStreamLine("Robot is not on line! Looking for line...");
			findLine(maxSensorNo, encoderValue, threshold, POWER, LOW_POWER);
		}
		else {
			encoderValue = SensorValue[rightEncoder];
		}
  }
}

void initPathsArray() {
	/* ======
     Path 1
     ====== */
  updateLinePart(paths[0][0], 0, BASE_DIST, -90);
  updateLinePart(paths[0][1], 0, BASE_DIST, 0);
  updateLinePart(paths[0][2], 0, BASE_DIST, 0);
  updateLinePart(paths[0][3], 0, BASE_DIST, 90);
  updateLinePart(paths[0][4], 0, BASE_DIST, 0);

  /* ======
     Path 2
     ====== */
  updateLinePart(paths[1][0], 0, BASE_DIST, -90);
  updateLinePart(paths[1][1], 0, BASE_DIST, 0);
  updateLinePart(paths[1][2], 0, BASE_DIST, -90);
  updateLinePart(paths[1][3], 0, BASE_DIST, 0);

  /* ======
     Path 3
     ====== */
  updateLinePart(paths[2][0], 0, BASE_DIST, -90);
  updateLinePart(paths[2][1], 0, BASE_DIST, 90);
  updateLinePart(paths[2][2], 0, BASE_DIST, 0);

  /* ======
     Path 4
     ====== */
  updateLinePart(paths[3][0], 0, BASE_DIST, 90);
  updateLinePart(paths[3][1], 0, BASE_DIST, -90);
  updateLinePart(paths[3][1], 0, BASE_DIST, 0);
}

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
  StartTask(watchForStop);  // Watch for stop button presses

  // Set line parts
  initPathsArray();

  wait1Msec(2000);

  StartTask(watchLine);  // Make sure that robot is on line

  for (int i = 0; i < sizeof(paths) / sizeof(paths[0]); i++) {
  	for (int k = 0; k < 2; k++) {
  		writeDebugStreamLine("-------------");
  		writeDebugStream("PATH %d ", i);
  		if (k == 0) {
  			writeDebugStreamLine("(forward)");
  		}
  		else {
  			writeDebugStreamLine("(backwards)");
  		}
  		const int maxJ = sizeof(paths[i]) / sizeof(paths[i][0]);
	  	for (int j = 0; j < maxJ; j++) {
				int startTurn;
				int endTurn;

				bool startTurnDir;
				bool endTurnDir;

				int distance;

				// Go in reverse if k == 1
				if (k == 0) {
					startTurn = paths[i][j].startTurn;
					endTurn = paths[i][j].endTurn;
					distance = paths[i][j].distance;
				}
				else {
					// Get array element from right
					startTurn = -paths[i][maxJ-j-1].endTurn;
					endTurn = -paths[i][maxJ-j-1].startTurn;
					distance = paths[i][maxJ-j-1].distance;
				}

				startTurnDir = startTurn >= 0;
				endTurnDir = endTurn >= 0;

				// Skip line part if it has no startTurn, distance or endTurn
				if (startTurn == 0 && distance == 0 && endTurn == 0) {
					continue;
				}

				while (!isOnLine) {}

	  		writeDebugStreamLine("\nPart %d", j);

	  		writeDebugStreamLine("Start turn: %d", startTurn);
	  		turn(BASE_TURN * (float)abs(startTurn) / 360.0, startTurnDir);
	  		wait1Msec(500);

	  		writeDebugStreamLine("Distance: %d", distance);
	  		followLineForDistance(distance, true, threshold, FULL_POWER, LOW_POWER);
	  		stopMotors();
	  		wait1Msec(500);

	  		writeDebugStreamLine("End turn: %d", endTurn);
	  		turn(BASE_TURN * (float)abs(endTurn) / 360.0, endTurnDir);
	  		wait1Msec(500);
	  	}
	  	writeDebugStreamLine("-------------\n");
	  	writeDebugStreamLine("Turning around...\n");
	  	turn(BASE_TURN * 180.0 / 360.0, true);  // Turn around
	  	wait1Msec(500);
	  }
	}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
